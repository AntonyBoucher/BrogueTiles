<html>
<head>
<meta charset="utf-8" />
<style>
body {
    color: black;
    background-color: #ccc;
}
canvas, img {
    display: inline;
    background-color: #000;
    border: 0px;
    margin-right: 5px;
    vertical-align: top;
}
.choice {
    color: blue;
    text-decoration: underline;
    cursor: pointer;
}
</style>
</head>
<body>
<p>This page uses a VERY SLOW algorithm for sharpening. Please be patient! It takes ~20 minutes to complete.</p>
<p>Choose aspect ratio (sharp, slow):
    <span class="choice" onclick="generate(0,1)">Default</span>
    <span class="choice" onclick="generate(1,1)">16:9</span>
    <span class="choice" onclick="generate(2,1)">16:10</span>
    <span class="choice" onclick="generate(3,1)">4:3</span>
</p>
<p>Choose aspect ratio (blurry, fast):
    <span class="choice" onclick="generate(0,0)">Default</span>
    <span class="choice" onclick="generate(1,0)">16:9</span>
    <span class="choice" onclick="generate(2,0)">16:10</span>
    <span class="choice" onclick="generate(3,0)">4:3</span>
</p>
<img id="hi-res" src="./tiles.png" style="display: none">
<script>


function ToImageData(width, height, vector) {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    const data = ctx.getImageData(0, 0, width, height);
    for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
            let value = vector[x + y * width]; // linear 0..1
            value = Math.sqrt(value) * 255; // gamma-compressed 0..255
            value = Math.min(Math.max(Math.round(value), 0), 255);
            const index = (x + y * width) * 4;
            data.data[index+0] = 255;
            data.data[index+1] = 255;
            data.data[index+2] = 255;
            data.data[index+3] = value;
        }
    }
    return data;
}

function Sharpen(width, height, vector) {
    if (width >= 20) return vector; // not needed for large tiles
    const v = Float64Array.from(vector);
    const f = (x,y) => v[x+y*width];
    const strength = 48;
    for (let y = 1; y < height-1; y++) {
        for (let x = 1; x < width-1; x++) {
            vector[x+y*width] = (
                f(x,y) * strength
                - (f(x-1, y) + f(x+1, y) + f(x, y-1) + f(x, y+1)) * 2
                - (f(x-1, y-1) + f(x+1, y+1) + f(x-1, y+1) + f(x+1, y-1))
            ) / (strength - 12);
        }
    }
    return vector;
}

function ComputeSum(vector) {
    return vector.reduce((a, b) => a + (b < 0.5 ? b : 1-b), 0);
}

function Downscale(idata, sw, sh, dw, dh, dx1, dx2, dx3, dy1, dy2, dy3) {
    const x1 = Math.round((1 + dx1) * sw / dw);
    const x2 = Math.round((dw/2 + dx1) * sw / dw);
    const x3 = Math.round((dw - 1 + dx2) * sw / dw);
    const y1 = Math.round((1 + dy1) * sh / dh);
    const y2 = Math.round((dh/2 + dy1) * sh / dh);
    const y3 = Math.round((dh - 1 + dy2) * sh / dh);

    const dxLU = new Int32Array(sw);
    for (let sx = 0; sx < sw; sx++) {
        if (sx < x1) dxLU[sx] = 0;
        else if (sx >= x3) dxLU[sx] = dw-1;
        else if (sx < x2) dxLU[sx] = Math.floor((dw/2-1)*(sx-x1)/(x2-x1) + 1);
        else dxLU[sx] = Math.floor((dw/2-1)*(sx-x2)/(x3-x2) + dw/2);
    }

    const dyLU = new Int32Array(sh);
    for (let sy = 0; sy < sh; sy++) {
        if (sy < y1) dyLU[sy] = 0;
        else if (sy >= y3) dyLU[sy] = dh-1;
        else if (sy < y2) dyLU[sy] = Math.floor((dh/2-1)*(sy-y1)/(y2-y1) + 1);
        else dyLU[sy] = Math.floor((dh/2-1)*(sy-y2)/(y3-y2) + dh/2);
    }

    const value = new Float64Array(dw * dh);
    const count = new Float64Array(dw * dh);

    let si = 0;
    const data = idata.data;
    for (let sy = 0; sy < sh; sy++) {
        const dy = dyLU[sy];
        for (let sx = 0; sx < sw; sx++) {
            const dx = dxLU[sx];
            const di = dx+dy*dw;
            let v = (data[si+1] / 255) * (data[si+3] / 255);
            v = v*v; // gamma 2.0
            value[di] += v;
            count[di] += 1;
            si += 4;
        }
    }

    for (let i = 0; i < dw*dh; i++) value[i] /= count[i];
    return value;
}

function Resize(idata, sw, sh, dw, dh, subpixel) {
    const step = 0.1; // pixels
    const choices = [];
    for (a = -5; a <= 5; a++)
        for (b = -10; b <= 10; b++)
            for (c = -5; c <= 5; c++)
                choices.push([a,b,c]);

    // find best horizontal shifts
    let hshifts = [0, 0, 0, 1e20];
    if (subpixel)
    for (shifts of choices) {
        const resized = Downscale(idata, sw, sh, dw, dh,
            shifts[0]*step, shifts[1]*step, shifts[2]*step,
            0, 0, 0);
        const sum = ComputeSum(resized);
        if (sum < hshifts[3]) hshifts = [shifts[0], shifts[1], shifts[2], sum];
    }

    // find best vertical shifts
    let vshifts = [0, 0, 0, 1e20];
    if (subpixel)
    for (shifts of choices) {
        const resized = Downscale(idata, sw, sh, dw, dh,
            hshifts[0]*step, hshifts[1]*step, hshifts[2]*step,
            shifts[0]*step, shifts[1]*step, shifts[2]*step)
        const sum = ComputeSum(resized);
        if (sum < vshifts[3]) vshifts = [shifts[0], shifts[1], shifts[2], sum];
    }

    return  ToImageData(dw, dh,
                Sharpen(dw, dh,
                    Downscale(idata, sw, sh, dw, dh,
                        hshifts[0]*step, hshifts[1]*step, hshifts[2]*step,
                        vshifts[0]*step, vshifts[1]*step, vshifts[2]*step)));
}

function Noise(w, h) {
    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d");
    const idata = ctx.getImageData(0, 0, w, h);
    for (let i = 0; i < idata.data.length; i++) idata.data[i] = 255;
    for (let i = 3; i < idata.data.length; i+=4) idata.data[i] = 0;

    const freq = 9;
    let rnd_state = 0;
    const rand = () => {
        rnd_state = (rnd_state * 69069 + 1234567) % 0x100000000;
        return rnd_state / 0x100000000;
    };

    for (let x = 0; x < w; x+=3) {
        for (let y = 0; y < h; y+=3) {
            z = (rand()*4)|0;
            x2 = x + [0,0,1,1][z];
            y2 = y + [0,1,0,1][z];
            if (x2 < w-1 && y2 < h-1) idata.data[(x2+y2*w)*4+3] = (32+32*rand()*rand())|0;
        }
    }

    const f = (x,y) => idata.data[((x%w)+(y%h)*w)*4+3];
    for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
            if ( f(x+1,y)+f(x+1,y+1)+f(x+1,y-1)
                +f(x-1,y)+f(x-1,y+1)+f(x-1,y-1)
                +f(x,y)+f(x,y+1)+f(x,y-1) == 0) {
                idata.data[(x+y*w)*4+3] = (32+32*rand()*rand())|0;
            }
        }
    }

    return idata;
}

function generate(aspectratio, subpixel) {
    for (let size = 1; size <= 15; size++) {
        let p = document.createElement("p");
        p.innerText = `Size ${size}:`;
        p.appendChild(build(size, aspectratio, subpixel));
        document.body.appendChild(p);
    }
}

function build(size, aspectratio, subpixel) {
    let widths;
    let heights;

    if (aspectratio == 1) { // 16:9
        widths  = [ 7,  8,  9, 10, 11, 12, 13, 15, 16, 17, 19, 22, 25, 31, 38];
        heights = [11, 13, 14, 16, 18, 20, 22, 24, 26, 28, 31, 36, 42, 52, 63];
    } else if (aspectratio == 2) { // 16:10
        widths  = [ 7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 21, 23, 25];
        heights = [13, 15, 17, 18, 20, 23, 24, 26, 28, 29, 31, 35, 39, 43, 47];
    } else if (aspectratio == 3) { // 4:3
        widths  = [ 7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21];
        heights = [15, 18, 20, 22, 24, 26, 29, 31, 33, 35, 38, 40, 42, 44, 46];
    } else {
        widths  = [ 7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 21, 24, 27];
        heights = [11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 38, 44, 49];
    }

    // tile counts
    const cols = 16;
    const rows = 8;

    // tile size
    const twidth = widths[size-1];
    const theight = heights[size-1];

    // canvas size
    const cwidth = twidth * cols;
    const cheight = theight * rows;
    const canvas = document.createElement("canvas");
    canvas.width = cwidth;
    canvas.height = cheight;

    // resize tiles
    const ctx = canvas.getContext("2d");
    const img = document.getElementById("hi-res");
    const tw = img.width / cols;
    const th = img.height / rows;
    const imgcan = document.createElement("canvas");
    imgcan.width = img.width;
    imgcan.height = img.height;
    const imgctx = imgcan.getContext("2d");
    imgctx.drawImage(img, 0, 0);
    for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
            let nw = twidth;
            let nh = theight;
            if (r == 0 && (c == 2 || c == 4 || c == 6 || c == 10 || c == 11 || c == 12 || c == 13 || c == 14 || c == 15)
                || r == 1 && (c == 0 || c == 1 || c == 3 || c == 5)
                || r == 2 && (c == 13)
                || r == 4 && (c == 1 || c == 15)
                || r == 6 && (c == 4 || c == 6 || c == 7 || c == 10)
                || r == 7 && (c == 4) )
            {
                // stretch
            } else {
                // fill
                if (nh > nw*29/16*1.1) nh = Math.floor(nw*29/16*1.1);
                else if (nw > nh*16/29*1.1) nw = Math.floor(nh*16/29*1.1);
            }
            const bigTile = imgctx.getImageData(c*tw, r*th, tw, th);
            const smallTile = Resize(bigTile, tw, th, nw, nh, subpixel);
            ctx.putImageData(smallTile,
                c*twidth + Math.floor((twidth-nw)/2),
                r*theight + Math.floor((theight-nh)/2));
        }
    }

    // floor
    const noise = Noise(twidth, theight);
    ctx.putImageData(noise, 2*twidth, 4*theight);

    // walls
    {
        const f = (row, col, x, y) => (((col*twidth+x) + (row*theight+y) * cwidth) * 4);
        const data = ctx.getImageData(0, 0, cwidth, cheight);
        const hwaves = Math.max(2, Math.round(twidth/4));
        const vwaves = Math.max(2, Math.round(theight/4));
        for (let y = 0; y < theight; y++) {
            for (let x = 0; x < twidth; x++) {
                const v = Math.sin((x/twidth*hwaves + y/theight*vwaves)*Math.PI*2)/2+0.5;
                data.data[f(5, 1, x, y)] = 255;
                data.data[f(5, 1, x, y)+1] = 255;
                data.data[f(5, 1, x, y)+2] = 255;
                data.data[f(5, 1, x, y)+3] = v*255;
                if (y < theight/2) {
                    data.data[f(0, 2, x, y)] = 255;
                    data.data[f(0, 2, x, y)+1] = 255;
                    data.data[f(0, 2, x, y)+2] = 255;
                    data.data[f(0, 2, x, y)+3] = Math.max(v*255, data.data[f(0, 2, x, y)+3]);
                    data.data[f(6, 4, x, y)] = 255;
                    data.data[f(6, 4, x, y)+1] = 255;
                    data.data[f(6, 4, x, y)+2] = 255;
                    data.data[f(6, 4, x, y)+3] = Math.max(v*255, data.data[f(6, 4, x, y)+3]);
                }
            }
        }
        ctx.putImageData(data, 0, 0);
    }

    return canvas;
}
</script>
</body>
</html>